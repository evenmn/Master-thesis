\chapter{Implementation} \label{sec:implementation}
In many cases, planning is half the job, and so is true for a good VMC implementation. In fact, the program was restructured three times before we landed on this final version. It is based on Morten Ledum's VMC framework [\url{https://github.com/mortele/variational-monte-carlo-fys4411}], which was meant as an example implementation in the course \textit{FYS4411 - Computational Physics II: Quantum Mechanical Systems}.

During the implementations we had two main areas of focus
\begin{itemize}
	\item Efficient code
	\item High legibility, tidy code
\end{itemize}

Unlike many other VMC codes, our code was developed flexible with respect to the wave functions. This means that one can combine various wave function elements, where each element is implemented separately. For instance, the simple Gaussian function and the Padé-Jastrow factor were implemented separately, but they can easily be combined. The way one does this in practice, is to append multiple wave function elements to the vector \texttt{WaveFunctionElements} in main. If one for instance want to combine the simple Gaussian with the Padé-Jastrow factor, this can be done by

\lstset{basicstyle=\scriptsize}
\begin{lstlisting}[language=c++]
System* system = new System();
std::vector<class WaveFunction*> WaveFunctionElements;
WaveFunctionElements.reserve(2);
WaveFunctionElements.push_back(new class SimpleGaussian(system, alpha));
WaveFunctionElements.push_back(new class PadeJastrow(system, beta, Gamma));
system->setWaveFunction             (WaveFunctionElements);
\end{lstlisting}

The big advantage of this implementation is that we do not need to hard code every possible combination of wave function elements, which reduces the number of code lines significantly. This also eases adding new elements, since we only need to calculate the derivatives of the particular element (do not need to worry about cross terms). Exactly how this is done can be read in Appendix \ref{chp:appendixd}. 

The con is that the program will be slightly slower. 

\section{Foundation} \label{subsec:foundation}
\section{Structure} \label{subsec:structure}
Add structure chart
\begin{figure} [H]
	\centering
	\begin{tikzpicture}[
	>={Latex[width=2mm,length=2mm]},
	base/.style = {rectangle, rounded corners, draw=black,
		minimum width=2cm, minimum height=0.5cm, text
		centered, font=\sffamily},
	basecode/.style = {rectangle, rounded corners, draw=black,
		minimum width=2cm, minimum height=0.5cm, text
		centered, font=\sffamily, align=left},
	activityStarts/.style = {base, fill=blue!30, drop shadow},
	startstop/.style = {base, fill=red!25, drop shadow},
	startstopcode/.style = {basecode, fill=Red!25, drop shadow},
	activityRuns/.style = {base, fill=green!25, drop shadow},
	process/.style = {base, fill=white!15, font=\sffamily, drop shadow},
	processcode/.style = {basecode, fill=white!15, font=\sffamily, drop shadow},
	scale=0.8, 
	node distance=1.5cm, 
	every node/.style={fill=white, font=\sffamily},
	align=center]
	\node (pre) [activityStarts] {
		Pre-build two-body matrix $D_{pqrs}$ \\
		Pre-build one-body matrix $h_{pq}$ \\
		Pre-build overlap matrix $S_{pq}$ \\
		Initialize $\blds{C}$ 
	};
	\node (Fock) [activityRuns, below of=pre, yshift=-1.2cm] {
		Set Fock-matrix $\blds{F}$
	};
	\node (Fockmix) [activityRuns, below of=Fock, yshift=-0.7cm] {
		Perform mixing of $\blds{F}$ \\
		(Optional)
	};
	\node (Fockmixeq) [process, right of=Fockmix, xshift=2.4cm] {
		\ref{eq:extrapolF}
	};
	\draw[->] (Fock) -- (Fockmix);
	\draw[-] (Fockmix) -- (Fockmixeq);
	\node (RHF) [process, above right of=Fock, xshift=3.0cm, yshift=-0.2cm] {
		Use \ref{eq:FockRestrictedDef} if RHF
	};
	\node (UHF) [process, below right of=Fock, xshift=3.0cm, yshift=0.1cm] {
		Use \ref{eq:UHFFockdef} if UHF
	};
	\draw[-] (Fock) to [out=15, in=180] (RHF);
	\draw[-] (Fock) to [out=-15, in=180] (UHF);
	\draw[->] (pre) -- (Fock);
	\node (eigcomp) [activityRuns, below of=Fock, yshift=-2.5cm] {
		Solve generalized \\ 
		eigenvalue problem. \\
		$\blds{F}\blds{C} = \blds{\varepsilon}\blds{S}\blds{C}$
	};
	\draw[->] (Fockmix) -- (eigcomp);
	\node (density) [activityRuns, below of=eigcomp] {
		Set density matrix $\blds{\rho}$.
	};
	\draw[->] (eigcomp) -- (density);
	\node (densityeq) [process, right of=density, xshift=2.5cm] {
		\ref{eq:densitymatrixdef}
	};
	\draw[-] (density) -- (densityeq);
	\node (mix) [activityRuns, below of=density] {
		Perform mixing of $\blds{\rho}$. \\
		(Optional)
	};
	\draw[->] (density) -- (mix);
	\node (mixeq) [process, right of=mix, xshift=2.5cm] {
		\ref{eq:mixing}
	};
	\draw[-] (mix) -- (mixeq);
	\node (conv) [startstop, below of=mix] {
		Check convergence.
	};
	\node (conveq) [process, right of=conv, xshift=2.5cm] {
		\ref{eq:HFconvthresh}
	};
	\draw[->] (mix) -- (conv);
	\draw[-] (conv) -- (conveq);
	\node (no) [above left of=conv, xshift=-4.0cm] {
		$\blds{\varepsilon}^{\text{HF}}_{\text{new}} -
		\blds{\varepsilon}^{\text{HF}}_{\text{old}} \geq \epsilon$
	};
	\draw[->] (conv) to [out=180,in=-90] (no);
	\node (keepOld) [process, above of=no, yshift=1.5cm, xshift=-0.5cm] {
		Save energy eigenvalues and \\
		density matrix(mixed). \\
		$\blds{\varepsilon}^{\text{HF}}_{\text{old}} =
		\blds{\varepsilon}^{\text{HF}}_{\text{new}}$ \\
		$\blds{\rho}_{\text{old}} = \blds{\rho}_{\text{new}}$
	};
	\draw[->] (no) to [out=90,in=-90] (keepOld);
	\draw[->] (keepOld) to [out=90,in=180] (Fock);
	\node (yes) [below of=conv] {
		$\blds{\varepsilon}^{\text{HF}}_{\text{new}} -
		\blds{\varepsilon}^{\text{HF}}_{\text{old}} < \epsilon$
	};
	\draw[->] (conv) -- (yes);
	\node (end) [activityStarts, below of=yes] {
		Output energy
	};
	\node (endeq) [process, right of=end, xshift=3.0cm] {
		\ref{eq:energyJKHF, eq:ch3Efunc}
	};
	\draw[->] (yes) -- (end);
	\draw[-] (end) -- (endeq);
	\end{tikzpicture}
	\caption{Hartree-Fock Algorithm.}
\end{figure}
\section{Optimization algorithms} \label{subsec:optimization}
\subsection{Stochastic Gradient Descent} \label{subsubsec:sgd}
\subsection{ADAM} \label{subsubsec:adam}