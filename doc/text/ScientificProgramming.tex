\chapter{Scientific Programming} \label{chp:scientificprogramming}
\epigraph{Great quote.}{Author}
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.4]{Images/example.png}
	\caption{Caption}
\end{figure}

Since this thesis is much about writing code, it is natural including a few words about it. 

The computer's language itself is binary, and is the lowest level. To translate commands to this language, we need a "translator", which is a language that fills the gap between the binary language and human commands. This language is categorized in levels based on how similar they are to the binary language. Low-level languages are similar to the binary language, which means fast but complicated. High-level languages are easy to work with, but are not as fast as low-level languages. Might mention grammar etc

One can either do \textit{procedural programming} or \textit{object oriented programming}. The former means that the code is written in the same order as the program flow goes, while one in the latter defines objects. 

\section{Object Orientated Programming}
In the everyday life, we are surrounded by objects all the time which we can place in different categories. For instance, a \textit{cat} is an object with a name, race, age and so on, and can be placed in the class \textit{animals}. In object oriented programming, the class could be implemented as

\lstset{basicstyle=\scriptsize}
\begin{lstlisting}[language=python]
class Animal:
  def __init__(self, animal, name, race, age):
    self.animal = animal
    self.name = name
    self.race = race
    self.age = age

  def __call__(self):
    return "%s is a %s that's %d years old and of the race %s"%(self.name, self.animal, self.age, self.race)
\end{lstlisting}
where...

The next step is to define an object, which in our case is the cat with name "Schrodinger":

\lstset{basicstyle=\scriptsize}
\begin{lstlisting}[language=python]
Alma = Animal("cat", "Schroedeger", "Ragdoll", 4)
print(Alma())
\end{lstlisting}
This implies that "Schrodinger" is a cat of race "Ragdoll" and of age 4. When calling this class from "Schrodinger", the class returns

\lstset{basicstyle=\scriptsize}
\begin{lstlisting}[language=python]
$python3 simple_class.py
>>> Schrodinger is a cat that's 4 years old and of the race Ragdoll
\end{lstlisting}

You might wonder how this is related to scientific programming. The answer is that it is often convenient to define various parts of the code as objects to increase the liability and maximize reuse of code. For example, we use various Hamiltonians, where each can be defined as a subclass of the Hamiltonian superclass. 

The code above is written in Python, but the exact task could be performed in C++. 

INCLUDE C++ IMPLEMENTATION

As one can see, 

In C++ one needs to define constructors and destructors. All variables used inside the functions are defines in the constructor, while they are removed in the destructor to free up memory.  In Python, the constructors are called \texttt{\_\_init\_\_} by default, and memory is handled automatically.

\subsection{Inheritance}
This is also called parent and child, respectively. 

Parent and child
Polymorphy: Child inherit from the parents. 
Virtual functions to achieve runtime polymorphism 
Should define virtual destructor as well 

\begin{enumerate}
	\item Single inheritance
	\item Multiple inheritances
\end{enumerate}

Python and C++ support multiple inheritances. Multilevel inheritance: Got child and grand child. Hierarchical inheritance: Parent got several children. https://www.geeksforgeeks.org/inheritance-in-python/

\subsection{Pointers}
Sometimes we do not want to send the object itself, but either its address, such that..

\subsection{Virtual Functions}
Often one wants to define a template of objects... where the super class defines which functions its objects should have. In C++, this can be achieved by virtual functions, functions with arguments specified but task undefined. Those functions are overwritten by the corresponding functions in the object (hence virtual), 

\subsection{Data types}
To not lose precision, it is important to choose the correct data type. As a thumb rule, a large integer should be declared as a \texttt{long int} (or just a \texttt{long}), and an extremely large float should be declared as a \texttt{long double}. However, normally it is sufficient to declare integers as \texttt{int}s and floats as \texttt{double}s. 

Some variables should always be non-negative, such as counters and variables that gives the number of something. In those situations, the prefix \texttt{unsigned} is useful because it does two things: 1. ensures that a negative number is never assigned to the variable, 2. increases the range in positive direction. In for-loops, the control variable will usually be declared as \texttt{unsigned int}.

When using a library some variable types are already set, for instance the length of a standard vector is always given as an \texttt{unsigned long}. In those cases, it is most appropriate to continue using that type. 

When we tell the pros, we should also tell the cons. With \texttt{unsigned} types there is always a risk for underflow, which means that the number explode if it ...

As an additional note, we often want to ensure that a variable is not changed inside a function. To prevent this, the arguments can be passed with the feature \texttt{const}, which raises an error if the respective variable is tried changed. 

\subsubsection{Data types in Eigen}
The open source template library for linear algebra, Eigen, will be used throughout the coding, and it comes with arrays of various properties. The most relevant ones are \texttt{VectorXi}, which has dynamic length and \texttt{int} data type and \texttt{VectorXd}, which has dynamic length and \texttt{double} data type. The Matrix class has equivalent objects. 

In cases where we have \textit{a priori} knowledge of the array size, we can replace the \texttt{X} with the actual size. A fixed $3\times 3$ matrix of type \texttt{double} can for example be declared as \texttt{Matrix3d}. According to the Eigen documentation, using fixed size is \textit{"...hugely beneficial to performance"}. \url{https://eigen.tuxfamily.org/dox/group__TutorialMatrixClass.html}.