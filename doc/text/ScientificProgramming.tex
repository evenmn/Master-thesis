\chapter{Scientific Programming} \label{chp:scientificprogramming}
\epigraph{Great quote.}{Author}
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.4]{Images/example.png}
	\caption{Caption}
\end{figure}

Since this scientific work is based on solving equations numerically on the computer, software development is a major part of the work. We will in this chapter go through the main concepts of scientific programming, and directly relate them to our code in the next chapter on implementation. As a motivation, we will serve a brief recap of the some historical milestones in scientific computing.

Computers have long been used for solving complex scientific problems. Actually, for a long time science was the main motivation of developing computers. Already in 1929, Egil Hylleraas used his primary mechanical desk calculator to calculate the ground state energy of the Helium atom, which remains a milestone in computational quantum chemistry and quantum chemistry in general \cite{helgaker_perspective_2000}. Later, pioneers like ...

Today's computers are much more advanced, but they are also way more used-friendly than the primary computers. ...


The computer's language itself is binary, and is the lowest level. To translate commands to this language, we need a "translator", which is a language that fills the gap between the binary language and human commands. This language is categorized in levels based on how similar they are to the binary language. Low-level languages are similar to the binary language, which means fast but complicated. High-level languages are easy to work with, but are not as fast as low-level languages. Might mention grammar etc

One can either do \textit{procedural programming} or \textit{object oriented programming}. The former means that the code is written in the same order as the program flow goes, while one in the latter defines objects. 

\section{Object orientated programming in Python}
In the everyday life, we are surrounded by objects all the time which we can place in different categories. For instance, a \textit{circle} is an object with properties like area, circumference and so on, and can be placed in the class \textit{shapes}. Other members of the class shapes might be square and triangle. In object oriented programming, we would call the main class, shapes, the \textit{parent}, while the sub-classes circle, square and triangle are the children. By this analogy, we form an inheritance were the children inherit from their parents. In Python, this inheritance can be implemented as

\lstset{basicstyle=\scriptsize}
\begin{lstlisting}[language=python]
import numpy as np

class Shapes:
	def __init__(self, r):
		self.r = r

	def getArea(self):
		raise NotImplementedError("Class {} has no instance 'getArea'."
				.format(self.__class__.__name__))


class Circle(Shapes):
	def getArea(self):
		return np.pi*self.r**2

	def getCircumference(self):
		return 2*np.pi*self.r

	def getExtent(self, x, y):
		if np.linalg.norm([x,y]) < self.r:
			return True
		return False

class Square(Shapes):
	def getArea(self):
		return 4*self.r**2

	def getCircumference(self):
		return 8*self.r

	def getExtent(self, x, y):
		if abs(x) < self.r and abs(y) < self.r:
			return True
		return False

class Triangle(Shapes):
	def getCircumference(self):
		return 6*self.r
\end{lstlisting}
where we give the children the properties area, circumference and extent. The length \texttt{r} means the radius of a circle, half the side length of a square and also half a side length of the equilateral triangle. We can now define the objects "circ", "squr" and "tria" as

\lstset{basicstyle=\scriptsize}
\begin{lstlisting}[language=python]
circ = Circle(1)
squr = Square(1)
tria = Triangle(1)
\end{lstlisting}
where all have \texttt{r}=1, and try to compute their area as

\lstset{basicstyle=\scriptsize}
\begin{lstlisting}
>>> circ.getArea()
3.141592653589793

>>> squr.getArea()
4

>>> tria.getArea()
NotImplementedError: Class Triangle has no instance 'getArea'.
\end{lstlisting}

As we can see, the area of the circle and the square were calculated successfully, while the area of the triangle raised an error, which is obviously because we do not have defined the area of the triangle! This example illustrates that properties of the children overwrites the properties of the parent, but if the children does not have the called property, it will instead return the parent's property. 

\subsubsection{An example based on Monte-Carlo simulations}
Up to this point, we have talked a lot about Monte-Carlo simulations without giving a illustrating example on what it is. Methods where we draw numbers randomly from a function to reveal properties of the function are in general categorized as Monte-Carlo simulations. 

Suppose we did not know the value of $\pi$, what could we do to approximate its value? There are many ways to do this, where the most intuitive might be to measure the ratio between the diameter and the circumference in a circle. It is not possible to do this very accurate manually. A more accurate and robust solution would be to use Monte-Carlo simulations, where we for instance can take the starting point on the relation
\begin{equation}
\pi=4\frac{\text{A}_{\text{circle}}}{\text{A}_{\text{square}}}
\end{equation}
which is derived from the ratio between the circle area and the square area. By drawing random numbers from a uniform distribution and count the number of point which are in the square and in the circle, we can approximate $\text{A}_{\text{circle}}/\text{A}_{\text{square}}$. We can do this by using the \texttt{getExtent}-function of the square class and circle class,
\lstset{basicstyle=\scriptsize}
\begin{lstlisting}[language=python]
for i in range(1,10):					# Iteration loop
	M = 10**i
	A_square = 0
	A_circle = 0
	for _ in range(int(M)):				# Monte-Carlo loop
		x = np.random.uniform(-1,1)
		y = np.random.uniform(-1,1)
		if circ.getExtent(x,y):
			A_circle += 1
		if squr.getExtent(x,y):
			A_square += 1
	print("Pi: ", 4 * A_circle/A_square)
\end{lstlisting}
which gives the output
\begin{lstlisting}
Pi:  3.2
Pi:  3.04
Pi:  3.08
Pi:  3.1304
Pi:  3.15112
Pi:  3.140616
Pi:  3.1416464
Pi:  3.14159312
\end{lstlisting}
Considering the fact that $\pi=3.141592653589793...$, which is a quite good result. However, to produce the last approximation with $M=10^9$ Monte-Carlo cycles, the program spend a lot of time. How can we do this faster? The answer is by using a low-level language. 

\section{Low-level programming with C++}
Above, we looked at how inheritance can be implemented in the high-level language Python, and we observed the main weakness of high-level languages: the computational time. In this section we will repeat the implementation and example above using C++. This will, hopefully, provide a significantly speed-up. A similar class structure in C++ looks like
\lstset{basicstyle=\scriptsize}
\begin{lstlisting}[language=c++]
class Shapes {
	public:
	Shapes();
	virtual double getArea() = 0;
	virtual double getCircumference() = 0;
	virtual bool getExtent(double x, double y) = 0;
	virtual ~Shapes();
};

class Circle : public Shapes {
	public:
	Circle(double r);
	double getArea() {
		return M_PI * m_r * m_r;
	}
	double getCircumference() {
		return 2 * M_PI * m_r;
	}
	bool getExtent(double x, double y) {
		if(sqrt(x*x+y*y) < m_r) {
			return true;
		}
		return false;
	}
	private:
	double m_r = 1;
};

Circle::Circle(double r) : Shapes() {
	m_r = r;
}

class Square: public Shapes {
	public:
	Square(double r);
	double getArea() {
		return 4 * m_r * m_r;
	}
	double getCircumference() {
		return 8 * m_r;
	}
	bool getExtent(double x, double y) {
		if(fabs(x) < m_r && fabs(y) < m_r) {
			return true;
		}
		return false;
	}
	private:
	double m_r = 1;
};
Square::Square(double r) : Shapes() {
m_r = r;
}
\end{lstlisting}
which looks quite different from the implementation in Python. But do not panic! We will go thoroughly through the different part of the code. one of the first thing we observe, is that we here need to \textit{declare} all the variables, which means that we need to specify what find of variable it is. In the following we will have a look at some standard \textit{data types}.

\subsection{Data types}
To not lose precision, it is important to choose the correct data type. As a thumb rule, a large integer should be declared as a \texttt{long int} (or just a \texttt{long}), and an extremely large float should be declared as a \texttt{long double}. However, normally it is sufficient to declare integers as \texttt{int}s and floats as \texttt{double}s. 

Some variables should always be non-negative, such as counters and variables that gives the number of something. In those situations, the prefix \texttt{unsigned} is useful because it does two things: 1. ensures that a negative number is never assigned to the variable, 2. increases the range in positive direction. In for-loops, the control variable will usually be declared as \texttt{unsigned int}.

When using a library some variable types are already set, for instance the length of a standard vector is always given as an \texttt{unsigned long}. In those cases, it is most appropriate to continue using that type. 

When we tell the pros, we should also tell the cons. With \texttt{unsigned} types there is always a risk for underflow, which means that the number explode if it ...

As an additional note, we often want to ensure that a variable is not changed inside a function. To prevent this, the arguments can be passed with the feature \texttt{const}, which raises an error if the respective variable is tried changed. 

\subsection{Access modifiers}
Another thing that we observe from the code example above, is that we define the functions as \texttt{private} or \texttt{public}, which are called access modifiers. The access modifiers specify how much access the environment should have to the function: \texttt{private} means that the function can only be called from the particular class, while \texttt{public} means that also sub-classes (children) have access to the function. 

We also have a third access modifier in C++, called \texttt{protected}. 

\subsection{Virtual Functions}
Often one wants to define a template of objects... where the super class defines which functions its objects should have. In C++, this can be achieved by virtual functions, functions with arguments specified but task undefined. Those functions are overwritten by the corresponding functions in the object (hence virtual), 

\subsection{Constructors and destructors}

\subsection{Pointers}
In the example above, we have not directly used any pointer. However, pointers are important in low-level languages 

\subsection{Back to the Monte-Carlo example}
\begin{lstlisting}[language=c++]
int main() {   
	class Shapes* circ = new Circle(1);
	class Shapes* squr = new Square(1);

	for(int i=1; i<10; i++) {
		int M = int(pow(10,i));
		long A_square = 0;
		long A_circle = 0;
		for(int m=0; i<M; i++) {
			double x = uniform(gen);
			double y = uniform(gen);
			if(circ->getExtent(x, y)) {
				A_circle ++;
			}
			if(squr->getExtent(x, y)) {
				A_square ++;
			}
		}
		std::cout << std::fixed;
		std::cout << std::setprecision(10);
		std::cout << "Pi: " << 4 * double(A_circle)/A_square << std::endl;
	}
	return 0;
}
\end{lstlisting}
which gives the same output as the Python script, but is much faster. 

\iffalse
\subsection{Data types in Eigen}
The open source template library for linear algebra, Eigen, will be used throughout the coding, and it comes with arrays of various properties. The most relevant ones are \texttt{VectorXi}, which has dynamic length and \texttt{int} data type and \texttt{VectorXd}, which has dynamic length and \texttt{double} data type. The Matrix class has equivalent objects. 

In cases where we have \textit{a priori} knowledge of the array size, we can replace the \texttt{X} with the actual size. A fixed $3\times 3$ matrix of type \texttt{double} can for example be declared as \texttt{Matrix3d}. According to the Eigen documentation, using fixed size is \textit{"...hugely beneficial to performance"}. \url{https://eigen.tuxfamily.org/dox/group__TutorialMatrixClass.html}.
\fi